2048 (14)
Случайный ход конечно неплох, но намного круче реализовать возможность умного хода. В дебри нейронных сетей мы заходить не будем, для начала сконцентрируемся на достаточно простой идее.

Очевидно, хороший ход должен в итоге приближать нас к победе, а именно к получению плитки 2048.

Предлагаю рассмотреть такой вариант сравнения эффективности хода:
1. Первый ход является лучше второго, если после его совершения на поле находится больше пустых плиток, чем в результате второго хода.
2. Первый ход является лучше второго, если общий счет после его совершения больше, чем счет
полученный в результате второго хода.

Для того, чтобы реализовать такое сравнение, мы можем совершить ход, оценить его эффективность и потом отменить совершенный ход, чтобы вернуть игру в начальное состояние. Применив эту последовательность действий ко всем четырем вариантам хода, сможем выбрать наиболее эффективный ход и выполнить его.

Концептуально, нам понадобятся два класса, один будет описывать ход, а другой эффективность хода.

Создай интерфейс Move с одним void методом move. Отметь интерфейс аннотацией @FunctionalInterface, которая будет сигнализировать о том что в этом интерфейсе будет только один абстрактный метод.

Создай класс MoveEfficiency, описывающий эффективность хода. В нем нам понадобятся приватные поля numberOfEmptyTiles и score типа int, а также приватное поле поле move типа Move.
В классе MoveEfficiency необходим конструктор с тремя параметрами (int numberOfEmptyTiles, int score, Move move) для инициализации полей класса и геттер для поля move.


Requirements:
1. В интерфейсе Move должен присутствовать один абстрактный void метод move.
2. Интерфейс Move должен быть отмечен аннотацией @FunctionalInterface.
3. Конструктор класса MoveEfficiency должен корректно инициализировать поля класса.
4. В классе MoveEfficiency должен быть создан корректный геттер для поля move.